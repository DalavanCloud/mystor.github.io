<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Mystor's Box - Michael Layzell</title><link href="/" rel="alternate"></link><link href="/feeds/michael-layzell.atom.xml" rel="self"></link><id>/</id><updated>2017-03-20T07:17:00-04:00</updated><entry><title>"Wouldn't it be neat if you could write C++ inline in Rust?"</title><link href="/wouldnt-it-be-neat-p1.html" rel="alternate"></link><published>2017-03-20T07:17:00-04:00</published><updated>2017-03-20T07:17:00-04:00</updated><author><name>Michael Layzell</name></author><id>tag:None,2017-03-20:/wouldnt-it-be-neat-p1.html</id><summary type="html">&lt;p&gt;In June of 2015, I had an idea. At the time, I was obsessed with compilers, and
what was possible to do at compile time. For one of the languages which I was
working on, I got excited by the idea that I could have flawless C++ interop by
embedding â€¦&lt;/p&gt;</summary><content type="html">&lt;p&gt;In June of 2015, I had an idea. At the time, I was obsessed with compilers, and
what was possible to do at compile time. For one of the languages which I was
working on, I got excited by the idea that I could have flawless C++ interop by
embedding all of &lt;a href="https://clang.llvm.org"&gt;clang&lt;/a&gt; inside of the compiler, and
have a special &lt;code&gt;c++ {}&lt;/code&gt; form which would allow you to directly write C++ code
inside the program, and give that code access to the stack variables currently
in scope.&lt;/p&gt;
&lt;p&gt;That language never came into fruition, but at the time I was also interested in
another language, which I was going to use to implement my
language, &lt;a href="https://rust-lang.org"&gt;Rust&lt;/a&gt;. Rust was very interesting to me,
because in 2014 it had been one of the first times I had ever written
"system-level" code. I loved the way it seemed to make everything possible with
apparently no overhead. However, I had run into some problems. I wanted to
use &lt;a href="https://llvm.org"&gt;LLVM&lt;/a&gt; to implement the compiler back-end for the language
I was working on, but the best LLVM bindings were written in C++, and using them
from Rust was a tedious experience, to say the least. No good LLVM bindings were
available yet for Rust, so I would pretty much have to write them myself.&lt;/p&gt;
&lt;p&gt;I, naturally, started wishing that I had the &lt;code&gt;c++ {}&lt;/code&gt; block feature in Rust, to
help me write my new programming language. I really enjoy abusing meta
programming features in languages to let me do things which their creators never
intended, so I started concocting ideas as to how I could implement this using
Rust's unstable plugin infrastructure.&lt;/p&gt;
&lt;p&gt;Thus, &lt;a href="https://github.com/mystor/rust-cpp"&gt;rust-cpp&lt;/a&gt; was born.&lt;/p&gt;
&lt;p&gt;You can still find the code for this original version of rust-cpp, although
you'll have trouble getting it to build, archived under
the
&lt;a href="https://github.com/mystor/rust-cpp/tree/legacy_macros1.1_v0"&gt;&lt;code&gt;legacy_rustc_plugin&lt;/code&gt;&lt;/a&gt; branch.&lt;/p&gt;
&lt;p&gt;This initial version of rust-cpp was built with 2 parts, and remains possibly
the most powerful version of rust-cpp to this day. Firstly, it contained a
procedural macro, &lt;code&gt;cpp!&lt;/code&gt;, which would perform the Rust codegen, and store
the information parsed in some global state, and then a lint pass, which would
discover the type information for the callsites, and actually generate and compile
the C++ code.&lt;/p&gt;
&lt;p&gt;An example use of this API might look like:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;: &lt;span class="kt"&gt;i32&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;: &lt;span class="kt"&gt;i32&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cpp_result&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;unsafe&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;cpp&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-&amp;gt; &lt;span class="kt"&gt;i32&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;int32_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;int32_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;})&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This invocation would "capture" the local variables &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; in the &lt;code&gt;cpp!&lt;/code&gt;
closure, exposing those variable names to the C++ code. the closure itself then
would return a &lt;code&gt;i32&lt;/code&gt;. The C++ code would be contained with a function
invocation, such that the interface looks correct.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;cpp!&lt;/code&gt; macro expansion would produce some code which would look something
like the following:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cp"&gt;#[link(name = &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;rust_cpp_tmp&amp;quot;&lt;/span&gt;&lt;span class="cp"&gt;, kind = &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;static&amp;quot;&lt;/span&gt;&lt;span class="cp"&gt;)]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;extern&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;C&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;rust_cpp_936DA01F9ABD4d9d80C702AF85C822A8&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;: &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;u8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;: &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;u8&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-&amp;gt; &lt;span class="kt"&gt;i32&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;rust_cpp_936DA01F9ABD4d9d80C702AF85C822A8&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;as&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;_&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;as&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;u8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;as&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;_&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;as&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;u8&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;It would then also record the information parsed from the declaration (the names
of the arguments, the body text extracted from the original span as a string,
etc.) in the global storage.&lt;/p&gt;
&lt;p&gt;Then, the lint pass would run. It would walk the typechecked AST, looking at
every function call. If the function call begain with the name &lt;code&gt;rust_cpp_&lt;/code&gt;, it
would be considered as a &lt;code&gt;rust-cpp&lt;/code&gt; call. The matching function would be looked
up from global storage.&lt;/p&gt;
&lt;p&gt;We would then look at the pre-casting types of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, and try to guess the
C++ type from them. If we failed, we would default to passing an opaque type to
C++.&lt;/p&gt;
&lt;p&gt;Once the lint pass had seen every function call which was generated earlier by
the &lt;code&gt;cpp!&lt;/code&gt; procedural macro, it would write out a &lt;code&gt;rust_cpp_tmp.cpp&lt;/code&gt; file, which
would then be shelled out to the native c++ compiler. The above function would
have been generated similar to the following:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/******************************&lt;/span&gt;
&lt;span class="cm"&gt; * Code Generated by Rust-C++ *&lt;/span&gt;
&lt;span class="cm"&gt; ******************************/&lt;/span&gt;

&lt;span class="cm"&gt;/* cstdint includes sane type definitions for integer types */&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;cstdint&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="cm"&gt;/* the rs:: namespace contains rust-defined types */&lt;/span&gt;
&lt;span class="k"&gt;namespace&lt;/span&gt; &lt;span class="n"&gt;rs&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="cm"&gt;/* A slice from rust code */&lt;/span&gt;
    &lt;span class="cm"&gt;/* Can be used to interact with, pass around, and return Rust slices */&lt;/span&gt;
    &lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Slice&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;  &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kt"&gt;uintptr_t&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;};&lt;/span&gt;

    &lt;span class="cm"&gt;/* A string slice is simply a slice of utf-8 encoded characters */&lt;/span&gt;
    &lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="n"&gt;Slice&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;uint8_t&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;StrSlice&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="cm"&gt;/* A trait object is composed of a data pointer and a vtable */&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;TraitObject&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;vtable&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;};&lt;/span&gt;

    &lt;span class="cm"&gt;/* A dummy struct which is generated when incompatible types are closed-over */&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;__Dummy&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;


    &lt;span class="cm"&gt;/* Typedefs for integral and floating point types */&lt;/span&gt;
    &lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="kt"&gt;uint8_t&lt;/span&gt; &lt;span class="n"&gt;u8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="kt"&gt;uint16_t&lt;/span&gt; &lt;span class="n"&gt;u16&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;u32&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="kt"&gt;uint64_t&lt;/span&gt; &lt;span class="n"&gt;u64&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="kt"&gt;uint64_t&lt;/span&gt; &lt;span class="n"&gt;usize&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="kt"&gt;int8_t&lt;/span&gt; &lt;span class="n"&gt;i8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="kt"&gt;int16_t&lt;/span&gt; &lt;span class="n"&gt;i16&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="kt"&gt;int32_t&lt;/span&gt; &lt;span class="n"&gt;i32&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="kt"&gt;int64_t&lt;/span&gt; &lt;span class="n"&gt;i64&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="kt"&gt;int64_t&lt;/span&gt; &lt;span class="n"&gt;isize&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;f32&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;static_assert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f32&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;C++ `float` isn&amp;#39;t 32 bits wide&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;f64&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;static_assert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f64&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;C++ `double` isn&amp;#39;t 64 bits wide&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="cm"&gt;/* We use this bool type to ensure that our bools are 1 byte wide */&lt;/span&gt;
    &lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="n"&gt;i8&lt;/span&gt; &lt;span class="n"&gt;bool_&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="cm"&gt;/* User-generated function declarations */&lt;/span&gt;
&lt;span class="k"&gt;extern&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;C&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;rs&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;i32&lt;/span&gt; &lt;span class="n"&gt;rust_cpp_936DA01F9ABD4d9d80C702AF85C822A8&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;rs&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;i32&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;rs&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;i32&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int32_t&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int32_t&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The code would then use an
&lt;a href="https://github.com/mystor/rust-cpp/blob/legacy_rustc_plugin/src/lint.rs#L206-L221"&gt;ugly hack&lt;/a&gt; to
insert the compiled static library into the &lt;code&gt;SearchPaths&lt;/code&gt; object, causing it to
be linked in when the compiler performs the final link step.&lt;/p&gt;
&lt;p&gt;This plugin was pretty cool. It could allow you to embed arbitrary C++ code into
your Rust code, was fairly easy to add, and inferred a lot of types for you to
boot! Unfortunately, it required unstable Rust, which meant that people
definitely couldn't use it, and also meant that I had to push a new version very
frequently to keep up with bustage.&lt;/p&gt;
&lt;p&gt;Eventually, I decided to rewrite &lt;code&gt;rust-cpp&lt;/code&gt;, and shed some of the cool features,
in persuit of it working on stable Rust, but that's a story for part 2.&lt;/p&gt;</content><category term="rust"></category><category term="rust-cpp"></category><category term="c++"></category><category term="ffi"></category></entry><entry><title>ClojureScript + Meteor</title><link href="/clojurescript-meteor.html" rel="alternate"></link><published>2014-04-27T08:14:00-04:00</published><updated>2014-04-27T08:14:00-04:00</updated><author><name>Michael Layzell</name></author><id>tag:None,2014-04-27:/clojurescript-meteor.html</id><summary type="html">&lt;p&gt;A few weeks ago, I released a plugin for Meteor, &lt;a href="https://github.com/mystor/meteor-clojurescript"&gt;meteor-clojurescript&lt;/a&gt;. The goal of this plugin was to make developing with Meteor in ClojureScript as easy as with any of the other languages which Meteor supports. The plugin certainly isn't at that state yet, but it's getting closer.&lt;/p&gt;
&lt;p&gt;Meteor has â€¦&lt;/p&gt;</summary><content type="html">&lt;p&gt;A few weeks ago, I released a plugin for Meteor, &lt;a href="https://github.com/mystor/meteor-clojurescript"&gt;meteor-clojurescript&lt;/a&gt;. The goal of this plugin was to make developing with Meteor in ClojureScript as easy as with any of the other languages which Meteor supports. The plugin certainly isn't at that state yet, but it's getting closer.&lt;/p&gt;
&lt;p&gt;Meteor has a build system which it uses for compiling and aggregating files.  Whenever a file changes, it walks the project's directory structure, calling package-provided callbacks for each file with a specific extension it finds.  This callback can then add raw css and javascript assets to the project, which will be compiled and served.&lt;/p&gt;
&lt;p&gt;This system works very well with compile-to-js languages like CoffeeScript, as they map one source file to one javascript output file. Working with languages with more complicated relationships (such as less files), has always been a bit of a pain point in Meteor (all @imported less files have to be given the extension &lt;code&gt;.lessimport&lt;/code&gt;, as every file with the extension &lt;code&gt;.less&lt;/code&gt; is compiled seperately).  &lt;/p&gt;
&lt;p&gt;Choosing the leiningen &lt;code&gt;project.clj&lt;/code&gt; file which accompanies most ClojureScript projects as the base file to compile, it is possible to fire &lt;code&gt;lein cljsbuild once&lt;/code&gt; every time a file changes, which will cause the clojurescript to be compiled into a file (presumably in an ignored directory), which is then read and provided to Meteor. Unfortunately, this is unacceptably slow. Every time &lt;code&gt;lein cljsbuild once&lt;/code&gt; is called, the JVM has to start up (twice), Clojure has to bootstrap itself, the ClojureScript compiler needs to initialize, the directory structure must be analyzed, and every file must be compiled, then the Google Closure compiler must be run to merge the inputs. On my computer, this would consistently take ~ 60 seconds on a small test project.&lt;/p&gt;
&lt;p&gt;That was unacceptable. Fortunately, the problem of faster compile times had already been, at least partially, solved. The command &lt;code&gt;lein cljsbuild auto&lt;/code&gt; would start the JVM and initialize the ClojureScript compiler, and then watch the directory structure for changes.  Whenever something changed, it would recompile (only the differences), and produce a new output file. Using &lt;code&gt;lein cljsbuild auto&lt;/code&gt;, compilations often only a few seconds (after the initial startup and first compile).&lt;/p&gt;
&lt;p&gt;By configuring leiningen to output the compiled code into a folder watched by Meteor, we could then cause the Meteor asset pipeline to re-run whenever the ClojureScript code was changed. &lt;/p&gt;
&lt;p&gt;However, simply dropping the JS code into the directory structure would be a bad idea, as source maps would not be correctly handled by Meteor, which would make development with ClojureScript much more difficult. In addition, the code generated by the &lt;code&gt;:nodejs&lt;/code&gt; target includes &lt;code&gt;require()&lt;/code&gt; calls, and a shebang at the top of the file, which would cause an error if passed into Meteor.&lt;/p&gt;
&lt;p&gt;To solve this problem, the code outputted by leiningen was given a &lt;code&gt;.cjs&lt;/code&gt; extension, and the sourcemap was outputted into the same directory. A Meteor extension handler was then created for the &lt;code&gt;.cjs&lt;/code&gt; extension, which would both load the source map, and perform the transformations on the code generated by the &lt;code&gt;:nodejs&lt;/code&gt; target.&lt;/p&gt;
&lt;p&gt;The leiningen subprocess was also started when the compiler plugin was loaded, and run in the background, such that a seperate leiningen process would not have to be started for development.&lt;/p&gt;
&lt;p&gt;This works fairly well, and you can use it today (just &lt;code&gt;mrt add clojurescript&lt;/code&gt;), however it has a few problems:
 - Meteor Smart Packages are completely unsupported, every top level project has exactly one ClojureScript compile target, and it is defined by the &lt;code&gt;project.clj&lt;/code&gt; file in the root of the project. This isn't as big of a problem (due to the package system already avaliable through leiningen for ClojureScript), and it does make sense to not have multiple copies of the ClojureScript/Closure core libraries.
 - Explicit control over which files are compiled is needed, rather than the implicit mechanism which is generally used by Meteor, meaning that ClojureScript doesn't feel as much like it is part of the Meteor ecosystem
 - Advanced compilation is not yet fully supported, as an externs file for Meteor hasn't been made, so any calls to the Meteor APIs will be munged
 - The compiler creates intermediate files on the disk within the project directory&lt;/p&gt;
&lt;p&gt;However, the potential in using Meteor's powerful reactivity API with the expressive power of ClojureScript is great. I can only see the plugin getting better as I gain familiarity with ClojureScript and the Meteor plugin system. For example, I have done some initial work on a hiccup-style templating interface for meteor-clojurescript, and it is turning out quite well.&lt;/p&gt;</content><category term="meteor"></category><category term="clojure"></category><category term="clojurescript"></category><category term="integration"></category></entry></feed>